<!DOCTYPE html>
<html lang="en">

<head>
    <title>Jak działa Async i Await</title>

    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width" />


    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:400,900&amp;subset=latin-ext" rel="stylesheet" />

    <!-- Shower Theme -->
    <link rel="stylesheet" href="vendors/shower-ribbon/styles/screen-16x9.css" />
    <link rel="stylesheet" href="vendors/shower-CezaryWalenciuk/styles/main.css" />

 
    
    <!-- Prism.js -->
    <link rel="stylesheet" href="vendors/prism/prism.css" />
    <link rel="stylesheet" href="vendors/prism/custom-prism.css" />
    <link rel="stylesheet" href="codegrid.css" />
</head>

<body class="shower list">
    <header class="caption">
        <h1>Jak działa Async i Await</h1>
        <p></p>
    </header>

    <section class="slide front-page">

        <div class="details">
            <!-- 1. Avatar -->


            <h2>Cezary Walenciuk</h2>

            <!-- 3. Presentation title -->
            <h2 class="bigbig"><strong style="font-size: 35px;  line-height: 1.3;">

                    <span class="titlec1">Jak działa </span>
                    <span class="">Async i Await</span></strong></h2>



            <!-- 5. Contact the speaker -->
            <h2><a href="https://twitter.com/WalenciukC">@walenciukC</a></h2>
        </div>
        <div>


            <!-- 2. Speaker -->

        </div>
        <div class="imag">
            <img src="images/my-avatar.jpg" alt="Speaker">
        </div>
    </section>
    <section class="slide dosblue">
        <span class="shout colors">Async i Await Task API
        </span>
    </section>
    <section class="slide grey  compact">
        <h2>Agenda</h2>
        <ol>
            <li class="next">Awaitables</li>
            <li class="next">TaskCompletionSource</li>
        </ol>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">Awaitables
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Awaitables</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 34px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 34px !important;">
                        TaskAwaiter awaiter = task.GetAwaiter();
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Awaitables</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 34px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 34px !important;">
                        static async Task Main()
                        {
                            int a = await RandomNumberAsync();
                        }
                        
                        private static Task<int> RandomNumberAsync()
                        {
                            return Task.FromResult(4);
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container2">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">Awaitables IsCompleted</h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 18px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 18px !important;">

                        static async Task Main()
                        {
                            Task&#x3C;int&#x3E; awaitableType = RandomNumberAsync();
                        
                            var awaiter = awaitableType.GetAwaiter();
                        
                            if (!awaiter.IsCompleted)
                            {
                                //robisz operacje kt&#xF3;ra nie jest zwi&#x105;zana
                                //z zako&#x144;czeniem tego zadania
                                //co&#x15B; mo&#x17C;e dzia&#x142;a&#x107; w tle
                                //To symulje kod przed wyra&#x17C;eniem await
                            }
                        
                            int a = awaiter.GetResult();
                            //kod po await
                        
                            //ten kod jest synchroniczny gdy&#x17C; nie jest on pakowany przez maszyn&#x119; stan&#xF3;w
                        }
                        
                        private static Task&#x3C;int&#x3E; RandomNumberAsync()
                        {
                            return Task.FromResult(4);
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide" style="background-color:black">
        <figure>
            <img class="cover" src="pictures/03.png" alt="blog">
            <figcaption class="white">Copyright © Cezary Walenciuk</figcaption>
        </figure>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Awaitables OnCompleted</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 26px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 26px !important;">
                        Task&#x3C;int&#x3E; awaitableType = RandomNumberAsync();
                            var awaiter = awaitableType.GetAwaiter();
                            
                            awaiter.OnCompleted(
                                () =&#x3E; { Console.WriteLine(&#x22;Koniec&#x22;); }
                            );
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide grey  compact">
        <h2>Pytania, które warto zadać</h2>
        <ol>
            <li class="next">Ile razy jest sprawdzana właściwość "IsCompleted" przez słowo kluczowe await?</li>
            <li class="next">Czy metoda OnCompleted() zawsze się uruchamia?</li>
            <LI class="next">Co dokładnie symbolizuje delegata Action "continuation".</LI>
        </ol>
    </section>
    <section class="slide grey  compact">
        <h2>Na czym możemy wywołać "await"? </h2>
        <ol>
            <li class="next">Na wszystkim co ma metodę "GetAwaiter()</li>
            <li class="next">Może to być metoda rozszerzeniowa</li>
        </ol>
    </section>
    <section class="slide grey  compact">
        <h2>Obiekt zwracany przez metodę GetAwaiter() musi mieć</h2>
        <ol>
            <li class="next">Implementacje INotifyCompletion i metodę "OnCompleted".</li>
            <li class="next">Posiadać pole IsCompleted</li>
            <li class="next">Posiadać metodę "GetResult()"</li>
        </ol>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Awaitables</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 34px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 34px !important;">
                        TaskAwaiter awaiter = task.GetAwaiter();
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">MyAwaitable</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 34px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 34px !important;">
                        public class MyAwaitable
                        {
                            public MyAwaiter GetAwaiter() => new MyAwaiter();
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container2">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">MyAwaitable</h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 22px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 22px !important;">

                        public class MyAwaiter : INotifyCompletion
                        {
                            public void OnCompleted(Action continuation)
                            {
                                Console.WriteLine("Przed OnCompleted");
                                continuation.Invoke();
                                Console.WriteLine("Po OnCompleted");
                            }
                        
                            public bool IsCompleted
                            {
                                get
                                {
                                    return true;
                                }
                            }
                        
                            public string GetResult()
                            {
                                return "Done";
                            }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">MyAwaitable</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 34px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 34px !important;">
                        static async Task Main()
                        {
                            var s = await new MyAwaitable();
                            Console.WriteLine(s);
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide grey  compact">
        <h2>W tym wypadku </h2>
        <ol>
            <li class="next">W swoim obiekcie "MyAwaiter" zwracam natychmiastowo wartość true dla właściwości IsCompleted</li>
            <li class="next">Nie uruchomi się metoda "OnCompleted"</li>
        </ol>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">Ile razy jest sprawdzana właściwość "IsCompleted" przez słowo kluczowe await?
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container2">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">MyAwaitable</h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 14px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 14px !important;">
                        public class MyAwaiter2 : INotifyCompletion
                        {
                            public void OnCompleted(Action continuation)
                            {
                                Console.WriteLine("Przed OnCompleted");
                                continuation.Invoke();
                                Console.WriteLine("Po OnCompleted");
                            }
                        
                            private bool _isCompleted = false;
                            public bool IsCompleted
                            {
                                get
                                {
                                    if (_isCompleted)
                                        return _isCompleted;
                        
                                    Random r = new Random();
                                    var number = r.Next(0, 100);
                        
                                    if (number > 90)
                                    {
                                        _isCompleted = true;
                                        return true;
                                    }
                                    return false;
                                }
                            }
                        
                            public string GetResult()
                            {
                                return "Done";
                            }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">Właściwość IsCompleted jest sprawdzana przez maszynę stanów tylko raz.
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Wiemy więc, że C# nie robi czegoś takiego:e</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 22px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 22px !important;">
                        var awaiter = new MyAwaitable().GetAwaiter();

                        while (!awaiter.IsCompleted)
                        {
                            Console.WriteLine("Czekam!");
                            Thread.Sleep(500);
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container2">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">IsCompleted jest zawsze FALSE</h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 19px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 19px !important;">
                        public class MyAwaiter3 : INotifyCompletion
                        {
                            public void OnCompleted(Action continuation)
                            {
                                Console.WriteLine("Przed OnCompleted");
                                continuation.Invoke();
                                Console.WriteLine("Po OnCompleted");
                            }
                        
                            private bool _isCompleted = false;
                            public bool IsCompleted
                            {
                                get
                                {
                                    return false;
                                }
                            }
                        
                            public string GetResult()
                            {
                                Thread.Sleep(4000);
                                return "Done";
                            }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide grey  compact">
        <h2>W tym wypadku </h2>
        <ol>
            <li class="next">Metoda OnCompleted() teraz się wykona, ponieważ początkowe sprawdzenie "IsCompleted" potwierdziło maszynie stanów, że jest to niby prawdziwa operacja asynchroniczna, która wymaga dalszego działania. </li>
        <li class="next">Później zobaczymy maszynę stanów "async i await" i to się wyjaśni, dlaczego tak się dzieje.</li>
        </ol>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">Pytanie 3 : Co dokładnie symbolizuje delegata Action "continuation".
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important" >
            Ta delegata ma reprezentować kod, który ma się wykonać po udanej operacji. 
            <br /><br />
            Bawiąc się kodem zauważyłem, że jeśli nie zrobimy wywołania tej delegaty "continuation" to cała aplikacja się zatrzyma.
            <br /><br />
            Dotyczy to wyrażenia "async i await", a nie,  synchronicznego wyrażenia bez maszyny stanów "GetAwaiter().GetResult()"
        </span>
    </section>
    <section class="slide" style="background-color:black">
        <figure>
            <img class="cover" src="pictures/03.png" alt="blog">
            <figcaption class="white">Copyright © Cezary Walenciuk</figcaption>
        </figure>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">Czy zauważyłeś, że metoda GetResult() w tych przykładach zwraca "string", ale zaraz przecież rezultatem akcji asynchronicznej mogą być nie tylko napisy.
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">IsCompleted jest zawsze FALSE</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 28px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 28px !important;">
                        public string GetResult()
                        {
                            Thread.Sleep(4000);
                            return "Done";
                        }

                        public int GetResult()
                        {
                            Thread.Sleep(4000);
                            return 1;
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">Jak się okazuje typ zwracany przez GetResult jest typem dynamicznym i może być w twoim "Awaiter" czymkolwiek.
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">Teraz gdy to wszystko wiemy, warto się zastanowić jak prawdziwie użyteczny "Awaiter" napisać. 
            Najłatwiej by było skorzystać z gotowego TaskAwaiter i otoczyć go swoim kodem.
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">Jednak tutaj chcemy się nauczyć jak taki Awaiter napisać dobrze od zera. Wszystkie poprzednie przykłady są niekompletne i tylko nauczyły nas jak maszyna stanów "async i await" działa.
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container2">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">Lepsza klasa "Awaitable" otwiera oczy na mechanizmy async i await</h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 22px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 22px !important;">

                        public class MyAwaitable4
                        {
                            private volatile bool finished;
                            public bool IsFinished => finished;
                            public event Action Finished;
                            public MyAwaitable4(bool finished) => this.finished = finished;
                            public void TryFinish()
                            {
                                if (finished) return;
                        
                                Random r = new Random();
                                var number = r.Next(0, 100);
                        
                                if (number > 95)
                                {
                                    finished = true;
                                    Finished?.Invoke();
                                }
                        
                            }
                            public MyAwaiter4 GetAwaiter() => new MyAwaiter4(this);
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container2">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">Lepsza klasa "Awaitable" otwiera oczy na mechanizmy async i await</h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 9px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 9px !important;">

                        public class MyAwaiter4 : INotifyCompletion
                        {
                            private readonly MyAwaitable4 awaitable;
                            private int result;
                        
                            public MyAwaiter4(MyAwaitable4 awaitable)
                            {
                                this.awaitable = awaitable;
                                if (IsCompleted)
                                    SetResult();
                        
                            }
                            public bool IsCompleted => awaitable.IsFinished;
                        
                            public int GetResult()
                            {
                                if (!IsCompleted)
                                {
                                    //var wait = new SpinWait();
                                    while (!IsCompleted)
                                    {
                                        Console.WriteLine("Czekam SPIN");
                                        awaitable.TryFinish();
                                        //wait.SpinOnce();
                                        Thread.Sleep(100);
                                    }
                        
                                }
                                return result;
                            }
                        
                            public void OnCompleted(Action continuation)
                            {
                                if (IsCompleted)
                                {
                                    continuation();
                                    return;
                                }
                                var capturedContext = SynchronizationContext.Current;
                                awaitable.Finished += () =>
                                {
                                    SetResult();
                                    if (capturedContext != null)
                                        capturedContext.Post(_ => continuation(), null);
                                    else
                                        continuation();
                                };
                                GetResult();
                            }
                        
                            private void SetResult()
                            {
                                result = new Random().Next();
                            }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Lepsza klasa "Awaitable" otwiera oczy na mechanizmy async i await</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 24px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 24px !important;">
                        static async Task Main()
                        {
                            var a = new MyAwaitable4(false);
                            var awaiter = a.GetAwaiter();
                            awaiter.OnCompleted(() => { Console.WriteLine("Dalsza część kodu"); });
                            var res = awaiter.GetResult();
                            Console.WriteLine(res);
                        
                            var b = new MyAwaitable4(false);
                            var res2 = await b;
                            //dalsza część kodu (dosłownie)
                            Console.WriteLine(res2);
                        
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" >
            Teraz warto odświeżyć wiedze. "a.GetAwaiter().GetResult()" i słowo kluczowe await to nie dokładnie te same operacje.
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            W swojej maszynie stanów "async i await" ma miejsce na wykonanie "a.GetAwaiter().GetResult()".
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            Pamiętaj a.GetAwaiter().GetResult() jest synchroniczny więc blokuje wątek główny. 
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Lepsza klasa "Awaitable" otwiera oczy na mechanizmy async i await</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size:20px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 20px !important;">

                        public void OnCompleted(Action continuation)
                        {
                            if (IsCompleted)
                            {
                                continuation();
                                return;
                            }
                            var capturedContext = SynchronizationContext.Current;
                            awaitable.Finished += () =>
                            {
                                SetResult();
                                if (capturedContext != null)
                                    capturedContext.Post(_ => continuation(), null);
                                else
                                    continuation();
                            };
                            GetResult();
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Lepsza klasa "Awaitable" otwiera oczy na mechanizmy async i await</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size:20px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 20px !important;">
                        public int GetResult()
                        {
                            if (!IsCompleted)
                            {
                                //var wait = new SpinWait();
                                while (!IsCompleted)
                                {
                                    Console.WriteLine("Czekam SPIN");
                                    awaitable.TryFinish();
                                    //wait.SpinOnce();
                                    Thread.Sleep(100);
                                }
                        
                            }
                            return result;
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">
            Naprawdę w TryFinish() bardzo ważne jest to, że uruchomi się delegata Finshed(), a ona obsłuży delegatę "continuation()". Jeżeli tak nie będzie to aplikacja nie uruchomi nic dalej po wyrażeniu "await". Widać jest to krytyczne dla działania maszyny stanu stworzonego przez wyrażenie "async i await".
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Lepsza klasa "Awaitable" otwiera oczy na mechanizmy async i await</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size:24px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 24px !important;">

                        public void TryFinish()
                        {
                            if (finished) return;
                        
                        
                            Random r = new Random();
                            var number = r.Next(0, 100);
                        
                            if (number > 95)
                            {
                                finished = true;
                                Finished?.Invoke();
                            }
                        
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            Ten przykład mógłby być jeszcze lepszy. 
        </span>
    </section>
    <section class="slide grey  compact">
        <h2>W tym wypadku </h2>
        <ol>
            <li class="next">Trzeba by było dodać jeszcze obsługę ConfigureAwait</li>
            <li class="next">Przydałaby się też obsługa braku SynchronizationContext</li>
        </ol>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            Na szczęście w swojej karierze nie będziesz musiał pisać takiego kodu.
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            Sensowne użycie awaitable z TaskAwaiter
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container2">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">CultureAwaiter</h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 15px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 15px !important;">

                        public static CultureAwaiter WithCurrentCulture(this Task task)
                        {
                            return new CultureAwaiter(task);
                        }
                        
                        public class CultureAwaiter : INotifyCompletion
                        {
                            private readonly TaskAwaiter m_awaiter;
                            private CultureInfo m_culture;
                        
                            public CultureAwaiter(Task task)
                            {
                                if (task == null) throw new ArgumentNullException(“task”);
                                m_awaiter = task.GetAwaiter();
                            }
                        
                            public CultureAwaiter GetAwaiter() { return this; }
                        
                            public bool IsCompleted { get { return m_awaiter.IsCompleted; } }
                        
                            public void OnCompleted(Action continuation)
                            {
                                m_culture = Thread.CurrentThread.CurentCulture; 
                                m_awaiter.OnCompleted(continuation);
                            }
                        
                            public void GetResult()
                            {
                                if (m_culture != null) Thread.CurrentThread.CurrentCulture = m_culture; 
                        
                                m_awaiter.GetResult();
                            }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container2">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">ControlAwaiter </h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 19px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 19px !important;">

                        public static ControlAwaiter GetAwaiter(this Control control)
                        {
                            return new ControlAwaiter(control);
                        }
                        
                        public struct ControlAwaiter : INotifyCompletion
                        {
                            private readonly Control m_control;
                        
                            public ControlAwaiter(Control control)
                            { 
                                m_control = control;
                            }
                        
                            public bool IsCompleted
                            { 
                                get { return !m_control.InvokeRequired; }
                            }
                        
                            public void OnCompleted(Action continuation)
                            { 
                                m_control.BeginInvoke(continuation); 
                            }
                        
                            public void GetResult() { }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            Jak to jest z metodami rozszerzeniowymi "GetAwaiter()".
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Jak to jest z metodami rozszerzeniowymi "GetAwaiter()".</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 21px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height: 21px !important;">

                        public static class TaskAwaiterHelper 
                        {
                            public static TaskAwaiter GetAwaiter(this TimeSpan timespan)
                            {
                                return Task.Delay(timespan).GetAwaiter();
                            }
                        
                            public static TaskAwaiter GetAwaiter(this string word)
                            {
                                return Task.Delay(word.Length).GetAwaiter();
                            }
                        
                            public static TaskAwaiter GetAwaiter(this DateTimeOffset dateTimeOffset)
                            {
                                return (dateTimeOffset – DateTimeOffset.UtcNow).GetAwaiter();
                            }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Jak to jest z metodami rozszerzeniowymi "GetAwaiter()".</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 43px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:43px !important;">
                        static async Task Main()
                        {
                            await TimeSpan.FromSeconds(2);
                            await "Stefan";
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            TaskCompletionSource
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            Pokaż jakiś fajny bajer z TaskCompletionSource 
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            Korzystając z TaskCompletionSource możesz opakować pewne działania, które nie zostały stworzone z myślą o "async i await".
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Przykład uruchamiania procesu</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 34px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:34px !important;">
                        static async Task Main()
                        {
                            var proces = Process.Start("notepad.exe");
                        
                            proces.WaitForExit();
                        
                            var result = proces.ExitCode;
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container2">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">Przykład uruchamiania procesu</h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 22px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:22px !important;">

                        public static class TaskAwaiterHelper
                        {
                            public static TaskAwaiter&#x3C;int&#x3E; GetAwaiter(this Process process)
                            {
                                var tsc = new TaskCompletionSource&#x3C;int&#x3E;(
                                    TaskCreationOptions.RunContinuationsAsynchronously);
                        
                                process.EnableRaisingEvents = true;
                                process.Exited += (sender, args) =&#x3E;
                                {
                                    var senderProcess = sender as Process;
                        
                                    if (senderProcess == null)
                                        return;
                        
                                    tsc.SetResult(senderProcess.ExitCode);
                                };
                        
                                return tsc.Task.GetAwaiter();
                            }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">
            Jak widzisz TaskCompletionSource posiada w sobie odpowiednie metody, aby zasymulować stworzenie Taska.
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">
            Dodatkowo trzeba skorzystać z opcji : TaskCreationOptions.RunContinuationsAsynchronously. Domyślne każda metoda kontynuowana pod takie Taski będą synchroniczne. Nie chcesz mieć takiej niespodzianki. Ta opcja też ratuje Cię przed pewnymi Deadlockami stworzonymi pod wpływem mieszania asynchronicznego kodu z synchronicznym. 
        </span>
    </section>
    <section class="slide grey  compact">
        <h2>Masz w TaskCompletionSource  metody do tworzenia innych stanów Taska.</h2>
        <ol>
            <li class="next">SetException() : Ustawia błędne zakończenie zadania</li>
            <li class="next">SetCanceled() : Ustawia stan zadania jako odwołane</li>
            <li class="next">SetResult()</li>
        </ol>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Korzystając z TaskCompletionSource możesz opakować każde stare API oparte na zdarzeniach</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 22px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:22px !important;">

                        public static Task PerformOperation(this PictureBox pictureBox)
                        {
                            var tcs = new TaskCompletionSource&#x3C;object&#x3E;();
                                    
                            // Naive version that does not unsubscribe from the event
                            pictureBox.LoadCompleted += (s, ea) =&#x3E;
                            {
                                if (ea.Cancelled) tcs.SetCanceled();
                                else if (ea.Error != null) tcs.SetException(ea.Error);
                                else tcs.SetResult(null);
                            };
                         
                            pictureBox.LoadAsync();
                         
                            return tcs.Task;
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">
            Sam TaskCompletionSource często był używany w testach jednostkowych. Przed .NET 4.5 nie było metody Task.FromResult i to tworzyło taki mankament pisania MOCK-ów. Zresztą w bibliotece Moq istnieje metoda ReturnAsync  więc ten problem obecnie nie powinien Cię spotkać.
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            Maszyna stanów : A co się dzieje jak robię await Task
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            <a href="https://www.markopapic.com/csharp-under-the-hood-async-await/ ">https://www.markopapic.com/csharp-under-the-hood-async-await/ </a>
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Maszyna stanów async i await</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 22px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:22px !important;">
                        static async Task BarAsync()
                        {
                            Console.WriteLine("This happens before await");
                        
                            int i = await QuxAsync();
                        
                            Console.WriteLine("This happens after await. The result of await is " + i);
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Maszyna stanów async i await</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 22px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:22px !important;">
                        private static Task BarAsync()
                        {
                          Program.&#x3C;BarAsync&#x3E;d__2 stateMachine;
                          stateMachine.&#x3C;&#x3E;t__builder = AsyncTaskMethodBuilder.Create();
                          stateMachine.&#x3C;&#x3E;1__state = -1;
                          stateMachine.&#x3C;&#x3E;t__builder.Start&#x3C;Program.&#x3C;BarAsync&#x3E;d__2&#x3E;(ref stateMachine);
                          return stateMachine.&#x3C;&#x3E;t__builder.Task;
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-containe2r">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">Maszyna stanów async i await</h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 10px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:10px !important;">
                        private struct &#x3C;BarAsync&#x3E;d__2 : IAsyncStateMachine
                        {
                          public int &#x3C;&#x3E;1__state;
                          public AsyncTaskMethodBuilder &#x3C;&#x3E;t__builder;
                          private TaskAwaiter&#x3C;int&#x3E; &#x3C;&#x3E;u__1;
                        
                          void IAsyncStateMachine.MoveNext()
                          {
                            &#x9;int num1 = this.&#x3C;&#x3E;1__state;
                            &#x9;try
                            &#x9;{
                            &#x9;  TaskAwaiter&#x3C;int&#x3E; awaiter;
                            &#x9;  int num2;
                            &#x9;  if (num1 != 0)
                            &#x9;  {
                            &#x9;&#x9;Console.WriteLine(&#x22;This happens before await&#x22;);
                            &#x9;&#x9;awaiter = Program.QuxAsync().GetAwaiter();
                            &#x9;&#x9;if (!awaiter.IsCompleted)
                            &#x9;&#x9;{
                            &#x9;&#x9;  this.&#x3C;&#x3E;1__state = num2 = 0;
                            &#x9;&#x9;  this.&#x3C;&#x3E;u__1 = awaiter;
                            &#x9;&#x9;  this.&#x3C;&#x3E;t__builder.AwaitUnsafeOnCompleted&#x3C;TaskAwaiter&#x3C;int&#x3E;, Program.&#x3C;BarAsync&#x3E;d__2&#x3E;(ref awaiter, ref this);
                            &#x9;&#x9;  return;
                            &#x9;&#x9;}
                            &#x9;  }
                            &#x9;  else
                            &#x9;  {
                            &#x9;&#x9;awaiter = this.&#x3C;&#x3E;u__1;
                            &#x9;&#x9;this.&#x3C;&#x3E;u__1 = new TaskAwaiter&#x3C;int&#x3E;();
                            &#x9;&#x9;this.&#x3C;&#x3E;1__state = num2 = -1;
                            &#x9;  }
                            &#x9;  Console.WriteLine(&#x22;This happens after await. The result of await is &#x22; + (object) awaiter.GetResult());
                            &#x9;}
                            &#x9;catch (Exception ex)
                            &#x9;{
                            &#x9;  this.&#x3C;&#x3E;1__state = -2;
                            &#x9;  this.&#x3C;&#x3E;t__builder.SetException(ex);
                            &#x9;  return;
                            &#x9;}
                            &#x9;this.&#x3C;&#x3E;1__state = -2;
                            &#x9;this.&#x3C;&#x3E;t__builder.SetResult();
                          }
                        
                          [DebuggerHidden]
                          void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
                          {
                            &#x9;this.&#x3C;&#x3E;t__builder.SetStateMachine(stateMachine);
                          }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide" style="background-color:black">
        <figure>
            <img class="cover" src="pictures/06.png" alt="blog">
            <figcaption class="white">Copyright © Cezary Walenciuk</figcaption>
        </figure>
    </section>
    <section class="slide" style="background-color:black">
        <figure>
            <img class="cover" src="pictures/07.png" alt="blog">
            <figcaption class="white">Copyright © Cezary Walenciuk</figcaption>
        </figure>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            Task.Yield
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            Czasami chciałbyś mieć pewność, że dalsze operacje po wykonaniu danego zadania na pewno też będą wykonywane asychroniczne
        </span>
    </section>


    <section class="slide prism over bhgry">
        <div class="grid-container2">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">Task.Yield</h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 21px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:21px !important;">

                        public struct YieldAwaiter : INotifyCompletion
                        {
                            public void OnCompleted(Action continuation)
                            {
                                ThreadPool.QueueUserWorkItem(new WaitCallback
                                    (
                                        (a) => { continuation(); }
                                    ));
                            }
                        
                            public bool IsCompleted
                            {
                                get
                                {
                                    return false;
                                }
                            }
                        
                            public void GetResult()
                            {
                        
                            }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors">
            Task.Yield zwraca gotowego "Awaiter-a" do takiego celu
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container2">
            <div class="HeaderTitle2">
                <h2 class="headerCODE2">Task.Yield</h2>
            </div>
            <div class="PlaceCodeHere2">
                <pre style="font-size: 15px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:15px !important;">
                        [SecurityCritical]
                        private static void QueueContinuation(Action continuation, bool flowContext)
                        {
                            ................
                            var syncCtx = SynchronizationContext.CurrentNoFlow;
                            if (syncCtx != null && syncCtx.GetType() != typeof(SynchronizationContext))
                            {
                                syncCtx.Post(s_sendOrPostCallbackRunAction, continuation);
                            }
                            else
                            {
                                TaskScheduler scheduler = TaskScheduler.Current;
                                if (scheduler == TaskScheduler.Default)
                                {
                                    if (flowContext)
                                    {
                                        ThreadPool.QueueUserWorkItem(s_waitCallbackRunAction, continuation);
                                    }
                                    else
                                    {
                                        ThreadPool.UnsafeQueueUserWorkItem(s_waitCallbackRunAction, continuation);
                                    }
                                }
                                // We're targeting a custom scheduler, so queue a task.
                                else
                                {
                                    Task.Factory.StartNew(continuation, default(CancellationToken), TaskCreationOptions.PreferFairness, scheduler);
                                }
                            }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode2">
                <div class="pytanie2">
                    <h3></h3>
                </div>
                <div class="odpowiedz2">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Task.Yield</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 39px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:39px !important;">
                        static async Task Main()
                        {
                            await Task.Yield();
                            //dalszy kod
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">
            Ogólnie Task.Yield prawie nie ma zastosowań, ale o zgrozo czasem nawet StackOverflow sugeruje aby go używać aby ulepszyć - responsywnie UI w WPF czy Windows Forms.
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">
            Wiadomo więcej asynchroniczności . Mniej blokowania wątku głównego UI to znaczy, że coś będzie działało szybciej.
        </span>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">
            Inne mechanizmy wątku UI, które mają niższy priorytety (jak reakcje na użytkownika)  w wyniku działania "Task.Yield" będą  blokowane.
        </span>
    </section>

    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Task.Yield to kiepski pomysł</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 29px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:29px !important;">
                        public async void MyButton_Click(object sender, RoutedEventArgs e)
                        {
                            for( int i=0; i < 10000; i++)
                            {
                                ProcessSomeStuff(i);
                        
                                // await the Yield to ensure all waiting messages
                                // are processed before continuing
                                await Task.Yield();
                            }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>

    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Task.Yield to kiepski pomysł</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 29px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:29px !important;">
                        async void Form_Load(object s, object e) 
                        { 
                            await Task.Yield(); 
                            MessageBox.Show("Async message!");
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">
            Form_Load wróci do swojego wywoływacza, czyli jakiegoś kodu w WindowsForms, który uruchomił zdarzenie Load. Później MessageBox pokaże się asynchronicznie gdzieś w przyszłej iteracji pętli zdarzeń, która wykonuje Application.Run.

            W tym wypadku kontekst "WinFormsSynchronizationContext.Post" wyśle wiadomość do wątku UI, który ma swoją pętle zdarzeń.  Ta wiadomość będzie wymuszona i co wie co zablokuje po drodze i mimo wszystko wykona się na tym samym wątku.
        </span>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Gdybyś chciał osiagnąć taki cel to byś napisał taki kod</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 22px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:22px !important;">
                        async Task DoUIThreadWorkAsync(CancellationToken token)
                        {
                            var i = 0;
                        
                            while (true)
                            {
                                token.ThrowIfCancellationRequested();
                        
                                await Dispatcher.Yield(DispatcherPriority.ApplicationIdle);
                        
                                // do the UI-related work item
                                this.TextBlock.Text = "iteration " + i++;
                            }
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide prism over bhgry">
        <div class="grid-container">
            <div class="HeaderTitle">
                <h2 class="headerCODE">Gdybyś chciał osiagnąć taki cel to byś napisał taki kod</h2>
            </div>
            <div class="PlaceCodeHere">
                <pre style="font-size: 22px;overflow: hidden;  " class="language-csharp">
                    <code style="line-height:22px !important;">
                        public static Task IdleYield()
                        {
                            var idleTcs = new TaskCompletionSource<bool>();
                            // subscribe to Application.Idle
                            EventHandler handler = null;
                            handler = (s, e) =>
                            {
                                Application.Idle -= handler;
                                idleTcs.SetResult(true);
                            };
                            Application.Idle += handler;
                            return idleTcs.Task;
                        }
                    </code>
                </pre>
            </div>
            <div class="AnswerCode">
                <div class="pytanie">
                    <h3></h3>
                </div>
                <div class="odpowiedz">
                    
                </div>
            </div>
          </div>
    </section>
    <section class="slide greenmemory">
        <span class="shout colors" style="font-size: 1.5em !important">
Task.Yield nie ma prawie zastosowania. Wyjątkiem jest pewien bug w ASP.NET i przypadki testów jednostkowych, które muszą być asychroniczne
        </span>
    </section>
    <!-- <div class="progress"></div> -->



    <footer class="badge badge-top-left">
        <a href="#" class="fullscreen">Fullscreen</a>
    </footer>

    <script src="vendors/gamepad/gamepad.js"></script>
    <script src="vendors/shower/shower.min.js"></script>
    <script src="vendors/shower-gamepad/shower.gamepad.js"></script>
    <script src="vendors/shower-warsawjs/scripts/fullscreen.js"></script>

    <!-- Prism.js -->
    <script src="vendors/prism/prism.js"></script>
    <script src="vendors/prism/custom-prism.js"></script>
    <script language="javascript">
        // var pre_elements = document.getElementsByTagName('pre');

        // for (var i = 0; i < pre_elements.length; i++)
        // {
        //     var content = pre_elements[i].innerHTML;

        //     var tabs_to_remove = '';
        //     while (content.indexOf('\t') == '0')
        //     {
        //       tabs_to_remove += '\t';
        //       content = content.substring(1);
        //     }

        //     var re = new RegExp('\n' + tabs_to_remove, 'g');
        //     content = content.replace(re, '\n');
        //     pre_elements[i].outerHTML = '<pre class="language-csharp">' + content + '</pre>';
        // }
    </script>
</body>

</html>